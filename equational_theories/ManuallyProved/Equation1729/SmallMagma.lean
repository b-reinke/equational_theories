import Mathlib.Algebra.DirectSum.Basic
import Mathlib.GroupTheory.FreeGroup.Basic
import Mathlib.Data.ZMod.Defs
import Mathlib.Data.Countable.Defs
import Mathlib.Data.DFinsupp.Encodable

import equational_theories.ForMathlib.GroupTheory.FreeGroup.ReducedWords
import equational_theories.Equations.All
import equational_theories.ManuallyProved.Equation1729.ExtensionTheorem

/- Constructs the small magma SM, basic properties of the additional set N, and sets out the axioms these objects need to satisfy -/

namespace Eq1729

/- SM is the abelian group generated by countably many generators E n of order 4 -/

abbrev SM := DirectSum ℕ (fun _ ↦ ZMod 4)

open AddToMagma -- makes SM a magma automatically

instance SM_countable : Countable SM := by
  convert instCountableDFinsupp
  . infer_instance
  infer_instance

abbrev E (n:ℕ) : SM := (DirectSum.of (fun _ ↦ ZMod 4) n) 1

/- The squaring map on SM -/
def S (a : SM) := a ◇ a

lemma SM_square_eq_double (a : SM) : S a = a + a := rfl

@[simp]
lemma S_zero : S 0 = 0 := rfl

@[simp]
lemma SM_square_square_eq_zero (a : SM) : S (S a) = 0 := by
  change (a+a) + (a+a) = 0
-- when we update Mathlib, one can switch to DirectSum.ext_component, or use the new version of DirectSum.ext
  apply DirectSum.ext ℤ
  intro i
  simp only [map_add, map_zero]
  abel_nf
  exact ZModModule.char_nsmul_eq_zero 4 _

lemma SM_obeys_1729 : Equation1729 SM := by
  intro x y
  change x = (y + y) + ((y+x) + y)
  abel_nf
-- when we update Mathlib, one can switch to DirectSum.ext_component, or use the new version of DirectSum.ext
  apply DirectSum.ext ℤ
  intro i
  simp only [map_add, map_smul, zsmul_eq_mul, Int.cast_ofNat, self_eq_add_left]
  apply zero_mul


/- N is the free group generated by e_a for each a in SM -/

abbrev N := FreeGroup SM

instance N_countable : Countable N := by
  apply Quotient.countable

abbrev e (a:SM) := FreeGroup.of a

def adjacent (x y : N) := ∃ a, x = (e a) * y ∨ y = (e a) * x

/-- Impose an order on N: x ≤ y if x is a right subword of y  (or equivalently, x is on the unique
simple path from 1 to y).  The spelling may not be optimal. -/
instance N_LE : LE N where
  le x y := x.toWord <:+ y.toWord

theorem le_def (x y : N) : (x ≤ y) = (x.toWord <:+ y.toWord) := rfl

instance N_order : PartialOrder N where
  le := N_LE.le
  le_refl _ := List.suffix_rfl
  le_trans _ _ _ := List.IsSuffix.trans
  le_antisymm x y hxy hyx := FreeGroup.toWord_injective <|
    List.IsSuffix.eq_of_length_le hxy (List.IsSuffix.length_le hyx)

instance : LocallyFiniteOrderBot N where
  finsetIic x := (List.map (FreeGroup.mk) x.toWord.tails).toFinset
  finsetIio x := (List.map (FreeGroup.mk) x.toWord.tails.tail).toFinset
  finset_mem_Iic a x := by
    simp only [List.mem_toFinset, List.mem_map, List.mem_tails, le_def]
    constructor
    · rintro ⟨a, h, eq⟩
      rw [← eq, FreeGroup.toWord_mk, FreeGroup.Red.reduced_iff_eq_reduce.mp]
      · exact h
      · exact FreeGroup.Red.reduced_infix (FreeGroup.reduced_toWord) h.isInfix
    · intro h
      use x.toWord
      simp [h, FreeGroup.mk_toWord]
  finset_mem_Iio a x := by
    simp only [List.mem_toFinset, List.mem_map, List.mem_tails, lt_iff_le_and_ne, le_def]
    cases h : a.toWord
    case nil => simp_all
    case cons head tail =>
      simp only [List.tails, List.tail_cons, List.mem_tails, ne_eq]
      constructor
      · rintro ⟨b, h', eq⟩
        have h'' : b <:+ head :: tail := h'.trans (List.suffix_cons ..)
        constructor
        · rw [← eq, FreeGroup.toWord_mk, FreeGroup.Red.reduced_iff_eq_reduce.mp]
          · exact h''
          · exact FreeGroup.Red.reduced_infix (FreeGroup.reduced_toWord) (h ▸ h''.isInfix)
        · intro eq'
          have : x.norm < x.norm := by
            calc x.norm
            _ = (FreeGroup.mk b).norm := by rw [eq]
            _ ≤ b.length := FreeGroup.norm_mk_le
            _ ≤ tail.length := h'.length_le
            _ < tail.length + 1 := Nat.lt_add_one _
            _ = (head :: tail).length := List.length_cons head tail
            _ = a.toWord.length := by rw [h]
            _ = x.norm := by rw [eq',FreeGroup.norm]
          exact (lt_self_iff_false (FreeGroup.norm x)).mp this
      · rintro ⟨h', ineq⟩
        use x.toWord
        rw [List.suffix_cons_iff] at h'
        cases h'
        case h.inl eq =>
          exfalso
          apply ineq
          apply FreeGroup.toWord_injective
          rw [eq, h]
        case h.inr h' => simp [h', FreeGroup.mk_toWord]

/-- the parent of x is defined to be the unique element adjacent to x whose reduced word is shorter, with the junk convention that the parent of the identity is itself -/
def parent (x : N) : N := FreeGroup.mk x.toWord.tail

theorem parent_toWord (x : N) : (parent x).toWord = x.toWord.tail := by
  rw [parent, FreeGroup.toWord_mk, FreeGroup.Red.reduced_iff_eq_reduce.mp]
  exact FreeGroup.Red.reduced_infix (FreeGroup.reduced_toWord) (List.tail_suffix _).isInfix

theorem parent_le (x : N) : parent x ≤ x := by
  rw [le_def, parent_toWord]
  exact List.tail_suffix _

theorem lt_iff_le_parent {x y : N} (h : y ≠ 1) : x < y ↔ x ≤ parent y := by
  rw [lt_iff_le_and_ne, le_def, le_def, parent_toWord]
  cases h' : y.toWord
  case nil =>
    simp only [List.suffix_nil, FreeGroup.toWord_eq_nil_iff, ne_eq, List.tail_nil,
    and_iff_left_iff_imp]
    intro eq1 eq2
    exact h (eq2 ▸ eq1)
  case cons head tail =>
    simp only [List.tail_cons, List.suffix_cons_iff]
    constructor
    · rintro ⟨(eq | h'), ineq⟩
      · exfalso
        apply ineq
        apply FreeGroup.toWord_injective
        rw [eq, h']
      · assumption
    · intro h''
      constructor
      · right
        exact h''
      · intro eq'
        rw [eq', h'] at h''
        simpa using h''.length_le

instance : OrderBot N where
  bot := 1
  bot_le x := by simp [le_def]

theorem bot_eq_one : (⊥ : N) = 1 := rfl

instance : PredOrder N where
  pred := parent
  pred_le := parent_le
  min_of_le_pred hap := by
    rw [isMin_iff_eq_bot]
    rw [le_def, parent_toWord] at hap
    have := hap.length_le
    simp only [List.length_tail] at this
    rw [bot_eq_one, ← FreeGroup.toWord_eq_nil_iff, ← List.length_eq_zero]
    omega
  le_pred_of_lt {a} {b} hab := (lt_iff_le_parent hab.ne_bot).mp hab

theorem parent_adjacent (x : N) (h : x ≠ 1) : adjacent x (parent x) := by
  cases h' : x.toWord
  case nil =>
    simp only [FreeGroup.toWord_eq_nil_iff] at h'
    exact (h h').elim
  case cons head tail =>
    have eq : x = FreeGroup.mk [head] * parent x := by
      rw [← FreeGroup.mk_toWord (x := parent x), parent_toWord, h', ← FreeGroup.mk_toWord (x := x),
      h']
      rfl
    nth_rw 1 [eq]
    rcases head with ⟨a,⟨⟩⟩
    · use a
      right
      have eq_inv : FreeGroup.mk [(a, false)] = (e a)⁻¹ := by
        simp only [e, FreeGroup.of, FreeGroup.inv_mk]
        rfl
      simp [eq_inv]
    · use a
      left
      rfl

/- Right-multiplication by an element of SM on N is defined via the group action. -/

abbrev R' (a:SM) (x:N) := (e a) * x

abbrev R'_inv (a:SM) (x:N) := (e a)⁻¹ * x

lemma R'_R'_inv_left (a:SM) : Function.LeftInverse (R'_inv a) (R' a) := inv_mul_cancel_left (e a)

lemma R'_R'_inv_right (a:SM) : Function.RightInverse (R'_inv a) (R' a) := mul_inv_cancel_left (e a)

@[simp]
lemma R'_inv_comp_R' (a:SM) : (R'_inv a) ∘ (R' a) = id := Function.LeftInverse.comp_eq_id (R'_R'_inv_left a)

@[simp]
lemma R'_comp_R'_inv (a:SM) : (R' a) ∘ (R'_inv a) = id := Function.RightInverse.comp_eq_id (R'_R'_inv_right a)

@[simp]
lemma comp_id {X:Type*} (f:X → X) : f ∘ id = f := rfl

@[simp]
lemma id_comp {X:Type*} (f:X → X) : id ∘ f = f := rfl

/-- The R' operators are bijective -/
lemma R'_bijective (a:SM) : Function.Bijective (R' a) := by
  rw [Function.bijective_iff_has_inverse]
  use R'_inv a
  exact ⟨ R'_R'_inv_left a, R'_R'_inv_right a ⟩

lemma R'_axiom_iia (a b : SM) (y:N) (h: a ≠ b): R' a y ≠ R' b y := by
  contrapose! h
  simp only [mul_left_inj] at h
  exact FreeGroup.of_injective h

lemma R'_axiom_iib (a : SM) (y:N) : R' a y ≠ y := by
  by_contra! h
  simp only [mul_left_eq_self, FreeGroup.of_ne_one] at h

/- Now we rewrite the axioms using a single transformation L₀' instead of many transformations L' -/

/- Not sure if this is the best spelling for this axiom -/
def axiom_i' (L₀' : N → N) : Prop := L₀' ∘ L₀' = R'_inv 0

def L' (L₀' : N → N) (a:SM) := (R'_inv a) ∘ L₀' ∘  (R' (S a))

def L'_inv (L₀' : N → N) (a:SM) := (R'_inv (S a)) ∘ L₀' ∘ (R' 0) ∘  (R' a)

lemma L'_0_eq_L₀' {L₀' : N → N} (h: axiom_i' L₀') : L' L₀' 0 = L₀' := by
  unfold L'
  rw [<- h, S_zero, Function.comp_assoc, <- Function.comp_assoc _ _ (R' 0), h, R'_inv_comp_R', comp_id]

lemma L'_L'_inv_left {L₀' : N → N} (h1: axiom_i' L₀') (a:SM) : Function.LeftInverse (L'_inv L₀' a) (L' L₀' a) := by
  unfold L' L'_inv
  unfold axiom_i' at h1
  rw [Function.leftInverse_iff_comp]
  calc
    _ = R'_inv (S a) ∘ L₀' ∘ R' 0 ∘ (R' a ∘ R'_inv a) ∘ L₀' ∘ R' (S a) := by ac_rfl
    _ = R'_inv (S a) ∘ L₀' ∘ R' 0 ∘ L₀' ∘ ((L₀' ∘ L₀') ∘ R' 0) ∘ R' (S a) := by
      simp only [R'_comp_R'_inv, R'_inv_comp_R', id_comp, h1]
    _ = R'_inv (S a) ∘ ((L₀' ∘ (R' 0 ∘ (L₀' ∘ L₀')) ∘ L₀') ∘ R' 0) ∘ R' (S a) := by ac_rfl
    _ = _ := by
      simp only [R'_comp_R'_inv, R'_inv_comp_R', id_comp, h1]


lemma L'_L'_inv_right {L₀' : N → N} (h1: axiom_i' L₀') (a:SM) : Function.RightInverse (L'_inv L₀' a) (L' L₀' a) := by
  unfold L' L'_inv
  unfold axiom_i' at h1
  rw [Function.rightInverse_iff_comp]
  calc
    _ = R'_inv a ∘ ((L₀' ∘ (R' (S a) ∘ R'_inv (S a)) ∘ L₀') ∘ R' 0) ∘ R' a := by ac_rfl
    _ = _ := by
      simp only [R'_comp_R'_inv, id_comp, h1, R'_inv_comp_R']

lemma L'_bijective {L₀' : N → N} (h1: axiom_i' L₀') (a:SM) : Function.Bijective (L' L₀' a) := by
  rw [Function.bijective_iff_has_inverse]
  use L'_inv L₀' a
  exact ⟨ L'_L'_inv_left h1 a, L'_L'_inv_right h1 a ⟩

def M := SM ⊕ N

variable (f g h : ℕ → ℕ)

example : ℕ := f $ g $ h 0

def axiom_iii' (S': N → SM) (L₀' : N → N)  : Prop := ∀ (a : SM) (x y : N), R' a x = y → (R'_inv (S' y) $ L₀' $ R' (S (S' y)) $ R'_inv (a - S' x) $ L₀' $ R' (S (a - S' x)) y) = x

def axiom_iv' (S': N → SM) (L₀' : N → N)  : Prop := ∀ x : N, (R'_inv (S' x) $ L₀' $ R' (S (S' x)) $ R'_inv (S' x) $ L₀' $ R' (S (S' x)) $ x) = x

def axiom_v (S': N → SM) (op: N → N → M) : Prop := ∀ x : N, op x x = Sum.inl (S' x)

def axiom_vi' (S': N → SM) (op: N → N → M) : Prop := ∀ (y : N) (a : SM), op (R' a y) y = Sum.inl (a - S' y)

def axiom_vii' (S': N → SM) (L₀' : N → N) (op: N → N → M) : Prop := ∀ x y : N, x ≠ y → (∀ a : SM, x ≠ R' a y) → ∃ z : N, op x y = Sum.inr z ∧ op z x = Sum.inr (R'_inv (S (S' x)) $ L₀' $ R' 0 $ R' (S' x) $ y)

lemma reduce_to_new_axioms {S': N → SM} {L₀' : N → N} {op: N → N → M} (hbij: Function.Bijective L₀') (h_i': axiom_i' L₀') (h_iii': axiom_iii' S' L₀') (h_iv': axiom_iv' S' L₀') (h_v: axiom_v S' op) (h_vi': axiom_vi' S' op) (h_vii': axiom_vii' S' L₀' op) : ∃ (G: Type) (_: Magma G), Equation1729 G ∧ ¬ Equation817 G := by sorry

end Eq1729
